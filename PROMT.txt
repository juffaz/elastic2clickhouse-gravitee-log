# Техническое описание проекта gravitee-sync

## Обзор проекта
gravitee-sync - это Clojure-приложение для синхронизации логов Gravitee из Elasticsearch в ClickHouse. Проект предназначен для эффективного переноса данных логов API-шлюза Gravitee из поискового движка Elasticsearch в аналитическую базу данных ClickHouse для дальнейшего анализа и мониторинга.

## Архитектура и структура кода

### Основные компоненты
- **core.clj**: Главная точка входа, реализует основной цикл синхронизации с периодическими запусками
- **config.clj**: Управление конфигурацией через переменные окружения
- **fetcher.clj**: Протокол для абстракции получения данных
- **search_after_fetcher.clj**: Реализация fetcher'а с использованием Elasticsearch search_after API
- **sync.clj**: Логика синхронизации, трансформация данных и обработка временных меток
- **clickhouse.clj**: Интеграция с ClickHouse для вставки данных
- **metrics.clj**: Простая система метрик и логирования производительности

### Технологии
- **Язык**: Clojure 1.11.1
- **HTTP-клиент**: clj-http 3.12.3
- **JSON-обработка**: Cheshire 5.11.0
- **Время**: clj-time 0.15.2
- **База данных**: ClickHouse JDBC 0.4.6, LZ4 compression
- **JDBC**: clojure.java.jdbc 0.7.12

## Функциональность

### Основные возможности
1. **Инкрементальная синхронизация**: Автоматическое определение последнего обработанного timestamp для продолжения синхронизации с места остановки
2. **Пакетная обработка**: Групповая вставка данных в ClickHouse для оптимизации производительности
3. **Поддержка различных форматов timestamp**: ISO8601, Java-style, Unix timestamp
4. **Сжатие данных**: LZ4 compression для эффективной передачи данных
5. **Отказоустойчивость**: Обработка ошибок и детальное логирование
6. **Конфигурируемость**: Настройка через переменные окружения

### Процесс синхронизации
1. Получение последнего timestamp из ClickHouse
2. Запрос данных из Elasticsearch с использованием search_after для пагинации
3. Трансформация данных (парсинг timestamp, маппинг полей)
4. Пакетная вставка в ClickHouse
5. Повторение цикла с заданным интервалом

## Плюсы

### Технические преимущества
- **Функциональный стиль**: Clojure обеспечивает immutable data structures и функциональный подход
- **JVM экосистема**: Доступ к богатой экосистеме Java библиотек
- **Простота развертывания**: Docker-контейнеризация, uberjar сборка
- **Эффективность**: Пакетная обработка и сжатие данных
- **Гибкость**: Поддержка различных форматов данных и конфигураций

### Архитектурные плюсы
- **Модульность**: Четкое разделение ответственности между компонентами
- **Расширяемость**: Протокол DataFetcher позволяет легко добавлять новые источники данных
- **Отказоустойчивость**: Graceful error handling и logging
- **Производительность**: Инкрементальная синхронизация и batch inserts

## Минусы

### Технические проблемы
- **Отсутствие типизации**: Динамическая типизация Clojure может привести к runtime ошибкам
- **Память**: Clojure может быть менее эффективным по памяти по сравнению с Java
- **Отладка**: Сложность отладки функционального кода с lazy sequences

### Архитектурные недостатки
- **Синхронная обработка**: Основной цикл работает последовательно, нет параллельной обработки
- **Ограниченное логирование**: Простая система метрик без интеграции с внешними системами мониторинга
- **Жесткая связанность**: Тесная интеграция с конкретными технологиями (ES + CH)
- **Отсутствие тестирования**: Нет видимых unit/integration тестов

### Проблемы качества кода
- **Отладочный код**: Много println для отладки в production коде
- **Обработка ошибок**: Базовая обработка исключений без детального анализа типов ошибок
- **Конфигурация**: Неполная конфигурация ClickHouse URL в config.clj (отсутствуют ch-host, ch-port, ch-db)
- **Производительность**: Потенциальные проблемы с памятью при больших объемах данных из-за eager evaluation в некоторых местах

## Рекомендации по улучшению

1. **Добавить тестирование**: Unit и integration тесты
2. **Улучшить обработку ошибок**: Более детальная классификация и обработка ошибок
3. **Оптимизировать производительность**: Внедрить асинхронную обработку и streaming
4. **Улучшить мониторинг**: Интеграция с Prometheus/Grafana
5. **Рефакторинг конфигурации**: Исправить ClickHouse конфигурацию
6. **Удалить отладочный код**: Заменить println на структурированное логирование
7. **Добавить типизацию**: Рассмотреть использование spec или schema для валидации данных
8. **Документация**: Добавить API документацию и примеры использования